import os
import re
import yaml
import logging

logger = logging.getLogger(__name__)

LOCAL_PATH = os.path.dirname(os.path.realpath(__file__))

def write_cwl_file(fname, target):
    """Writes [target] dictionary to a .cwl file with filename [fname]."""

    with open(fname, 'w', encoding='utf-8') as f:
        f.write("#!/usr/bin/env cwl-runner\n")
        yaml.dump(target, f, default_flow_style=False)

class CWLError(Exception):
    pass

class BaseCWL(object):

    def __init__(self, application, template_dir=os.path.join(LOCAL_PATH, 'templates')):

        self.app = application
        self.template_dir = template_dir

    def _read_template(self, app_cwl_fname):
        """Loads the template application CWL."""
        with open(app_cwl_fname, 'r') as f:
            return yaml.safe_load(f)

    def generate_all(self, outdir, **kwargs):
        """Calls all of the application CWL generators as well as the application descriptor generator.

        Returns the list of all files generated by this function (abs. path).
        """

        raise NotImplementedError("Only subclasses of this class implement this method")

class ProcessCWL(BaseCWL):

    def __init__(self, application, **kwargs):

        super().__init__(application, **kwargs)

        # Template CWL and descriptor files
        self.process_cwl = self._read_template( os.path.join(self.template_dir, 'process.cwl'))

    def generate_all(self, outdir, dockerurl="undefined", **kwargs):
        """Calls all of the application CWL generators as well as the application descriptor generator.

        Returns the list of all files generated by this function (abs. path).
        """

        generated_files = []
        generated_files.append(self.generate_process_cwl(outdir, dockerurl))

        return generated_files

    def _insert_argument_params(self):
        "Connect non stage in/out arguments to papermill parameters"

        # Forward the ordinary argument parameters to the process step directly
        input_dict = self.process_cwl['inputs']
        for param in self.app.arguments:
            name = param.name

            input_dict[name] = {
                'type': param.cwl_type,
                'default': param.default,
            }

    def _insert_input_params(self):
        "Connects the special 'input' CWL parameter to the papermill parameter for recieving the stage-in directory location"

        input_dict = self.process_cwl['inputs']
        
        # The input Directory is carried as an input from stage_in to process to
        # make sure that the contents are exposed to the process container
        #
        # If we had the stage_in collection filename be an input argument
        # to process.cwl then it would be volume mounted in a seperate path
        # and we could not assume that the collection file is in the same
        # directory as the staged in results
        if self.app.stage_in_param is not None:
            input_dict['input'] = 'Directory'

            self.process_cwl['arguments'] = self.process_cwl.get('arguments', [])
            self.process_cwl['arguments'] += [
                '-p', self.app.stage_in_param.name,
                f'$(inputs.input.path)'
            ]
    
    def _insert_output_params(self):
        "Connects the special 'input' CWL parameter to the papermill parameter for recieving the stage-out directory location"

        # Connect the stage-out parameter to the name of the file specified in the template as output
        # That value should contain a full path by using $(runtime.outdir)
        input_dict = self.process_cwl['inputs']

        if self.app.stage_out_param is not None:
            stage_out_process_dir = self.process_cwl['outputs']['output']['outputBinding']['glob']

            if not re.search('runtime.outdir', stage_out_process_dir):
                raise CWLError(f"The process CWL template outputs/output path needs to contain $(runtime.outdir) in the path")

            self.process_cwl['arguments'] = self.process_cwl.get('arguments', [])
            self.process_cwl['arguments'] += [
                '-p', self.app.stage_out_param.name, 
                stage_out_process_dir
            ]

        else:
            del self.process_cwl['outputs']['output']

    def generate_process_cwl(self, outdir, dockerurl):
        """Generates the application CWL.

        Returns the absolute path of the file generated by this function.
        """
        if not os.path.isdir(outdir):
            os.makedirs(outdir)

        # Set correct URL for process Docker container
        self.process_cwl['requirements']['DockerRequirement']['dockerPull'] = dockerurl

        # Forward the ordinary argument parameters to the process step directly
        self._insert_argument_params()
        
        # Handle input and output parameters and their connection to papermill arguments
        self._insert_input_params()
        self._insert_output_params()

        fname = os.path.join(outdir, 'process.cwl')
        write_cwl_file(fname, self.process_cwl)
        return fname


class DataStagingCWL(BaseCWL):

    def __init__(self, application, **kwargs):
        
        super().__init__(application, **kwargs)

        # Template CWL and descriptor files
        self.workflow_cwl = self._read_template( os.path.join(self.template_dir, 'workflow.cwl'))
        self.stage_in_cwl = self._read_template( os.path.join(self.template_dir, 'stage_in.cwl'))
        self.stage_out_cwl = self._read_template( os.path.join(self.template_dir, 'stage_out.cwl'))

    def generate_all(self, outdir, **kwargs):
        """Calls all of the application CWL generators as well as the application descriptor generator.

        Returns the list of all files generated by this function (abs. path).
        """

        generated_files = []

        generated_files.append(self.generate_workflow_cwl(outdir))
        generated_files.append(self.generate_stage_in_cwl(outdir))
        generated_files.append(self.generate_stage_out_cwl(outdir))

        return generated_files
    
    def generate_workflow_cwl(self, outdir):
        """Generates the workflow CWL.

        Returns the absolute path of the file generated by this function.
        """

        # Preocess step section of of workflow
        process_dict = self.workflow_cwl['steps']['process']

        # Add non stage-in/stage-out inputs to the master CWL input/outputs as parameters
        args_input_dict = self.workflow_cwl['inputs']['parameters']['type']['fields']
        for param in self.app.arguments:
            name = param.name

            # Add argument parameter to workflow input, allow null values so that default parameters 
            # from the notebook can be used
            args_input_dict[name] = [ 'null', param.cwl_type ]

            # Connect process step to input argument with the default coming from the notebook's value
            process_dict['in'][name] = {
                'source': 'parameters',
                'valueFrom': f'$(self.{name})',
            }

        # Connect the stage-in parameter to stage_in's collection filename output
        # Otherwise remove stage in from the workflow
        if self.app.stage_in_param is not None:
            process_dict['in']['input'] = 'stage_in/stage_in_download_dir'
        else:
            # No stage-in connected to notebook, delete
            del self.workflow_cwl['steps']['stage_in']
            del self.workflow_cwl['inputs']['stage_in']

        # Remove stage-out if not defined in the notebook
        # The connection of the parameter given to the notebook is done inside the process.cwl
        if self.app.stage_out_param is None:
            del self.workflow_cwl['steps']['stage_out']
            del self.workflow_cwl['inputs']['stage_out']
            del self.workflow_cwl['outputs']['stage_out_results']

        fname = os.path.join(outdir, 'workflow.cwl')
        write_cwl_file(fname, self.workflow_cwl)
        return fname
 
    def generate_stage_in_cwl(self, outdir):
        """Generates the stage-in CWL.

        Returns the absolute path of the file generated by this function.
        """
        if not os.path.isdir(outdir):
            os.makedirs(outdir)

        # Generate the stage-in CWL as is, no need for modification
        fname = os.path.join(outdir, 'stage_in.cwl')
        write_cwl_file(fname, self.stage_in_cwl)
        return fname
    
    def generate_stage_out_cwl(self, outdir):
        """Generates the stage-in CWL.

        Returns the absolute path of the file generated by this function.
        """
        if not os.path.isdir(outdir):
            os.makedirs(outdir)

        # Generate the outputs CWL as-is, no need for modifications
        fname = os.path.join(outdir, 'stage_out.cwl')
        write_cwl_file(fname, self.stage_out_cwl)
        return fname